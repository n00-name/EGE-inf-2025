def f1(start, end):
    if start == end:
        return 1
    elif start > end:
        return 0
    else:

        return f1(start + 2, end) + f1(start * 3, end) + f1(start ** 2, end)


print(f1(3, 13) * f1(13, 49))


def f2(start, forbidden, end):
    if start == end:
        return 1
    elif start > end or start == forbidden:
        return 0
    else:
        return f2(start + 2, forbidden, end) + f2(start * 3, forbidden, end) + f2(start ** 2, forbidden, end)


print(f2(3, 13, 49))

"""
В приведенном коде есть несколько проблем:

Базовый случай: В базовом случае функции f(start, end) не учитываются возможные случаи, когда число на пути достигает 13, что нарушает условие задачи.

Проблема с пересечением значений: Ваша задача заключается в том, чтобы при нахождении всех возможных путей от числа 3 до 49 избежать числа 13. В текущем решении программа не отслеживает, пересекается ли путь с числом 13.


Параметр forbidden: Мы добавили параметр forbidden, который указывает на число, которое не должно встретиться в пути. В нашем случае это число 13.
Условие: Если текущая точка start равна 13, функция сразу вернет 0, что означает, что мы исключаем этот путь.
Проверка конца пути: Когда мы достигаем конечной точки (в данном случае 49), функция возвращает 1, если путь не содержит запрещенного числа (13).
"""